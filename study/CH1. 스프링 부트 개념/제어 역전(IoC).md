#### 전통 방식
- 객체를 사용하기 위해선 선언하고 해당 객체의 기능(메서드)를 호출해서 사용했다.
```
// 객체 선언 및 의존성 생성
private MyService service = new MyServiceImpl();

// 객체의 기능 사용
service.getHello();
```

- 해당 방식의 문제점
	- 개발자가 객체의 생성 및 관리를 직접 해줘야 한다.


#### 제어 역전
- 사용할 객체를 개발자가 직접 생성하지 않고 객체의 생명주기 관리를 "스프링 컨테이너"에 위임한다.
- 제어 역전을 통해 의존성 주입, 관점 지향 프로그래밍이 가능해진다.

- 제어 역전으로 해결되는 문제
	- 개발자는 스프링 컨테이너에서 객체를 꺼내서 쓰면 되므로 비즈니스 로직 구현에 집중할 수 있다.
	- 객체 간의 의존성을 낮추고 코드의 결합도를 낮춘다.
		- 변경이나 확장에 유리하다.
	- 재사용성이 높고 테스트에 용이하다.
	


#### 질문거리
- 제어 역전이 어떻게 객체 간 의존성을 낮추는 걸까?

```
일반적으로 객체 간의 의존성은 객체가 다른 객체를 직접 생성하거나 참조함으로써 발생합니다. 이는 객체 간의 결합도를 높이고, 변경을 어렵게 만들며, 테스트를 어렵게 만듭니다. 예를 들어, 클래스 A가 클래스 B를 직접 생성하고 사용한다면, 클래스 A는 클래스 B에 의존성이 강하게 발생합니다.

그러나 제어 역전을 사용하면 객체 생성과 의존성 주입을 외부 컨테이너에게 위임함으로써 의존성을 느슨하게 만들 수 있습니다. 이는 다음과 같은 방식으로 이루어집니다:

1. **의존성 주입(Dependency Injection):** 객체가 직접 필요로 하는 의존 객체를 외부에서 주입받는 방식입니다. 즉, 객체가 자신이 필요로 하는 의존 객체를 스스로 생성하거나 관리하지 않고 외부에서 주입받습니다. 이렇게 되면 객체는 외부 컨테이너에 의존하게 되므로 의존성이 줄어듭니다.
    
2. **팩토리 메서드나 추상 팩토리 패턴 활용:** 객체를 생성하는 책임을 팩토리 메서드나 추상 팩토리에 위임하여 객체 간의 직접적인 의존성을 줄일 수 있습니다.
    

이렇게 하면 클래스 A가 직접 클래스 B를 생성하거나 참조하는 것이 아니라, 외부에서 생성된 클래스 B의 인스턴스를 주입받아 사용하므로 클래스 A는 클래스 B에 대해 덜 의존적이 됩니다. 이는 런타임 시에 객체 간의 관계를 결정하는 외부 컨테이너의 역할을 통해 이루어집니다. 결과적으로 객체 간의 결합도가 낮아지고, 변경이 쉬워지며, 테스트하기 쉬운 코드를 작성할 수 있습니다.
```
