#### 리포지토리
- 엔티티 객체를 DB 테이블에 CRUD 하기 위한 인터페이스
- JpaRepository를 상속 받아야 한다.


#### 작성법

```
@Repository  
public interface ProductRepository extends JpaRepository<Product, Long> {  
  // CRUD 메서드
}
```

- JpaRepository<엔티티 클래스, 엔티티 클래스의 PK 타입> 으로 상속받는다.
- 후에 원하는 CRUD 메서드들을 안에 명시한다.
	- 리포지토리 메서드 생성 규칙을 이용하여 CRUD 메서드를 생성한다.
		- FindBy, And, Or, Like, StartsWith, EndsWith, IsNull, True, Before, Between, OrderBy 등의 키워드를 이용해서 메서드 생성한다.


#### 질문거리
- 왜 JpaRepository 상속을 클래스가 아닌 인터페이스로 해야 하지?

```
1. **다중 상속 지원**: Java에서는 클래스의 다중 상속을 허용하지 않습니다. 하지만 인터페이스는 다중 상속을 지원하므로, 여러 인터페이스를 동시에 구현하여 다양한 기능을 사용할 수 있습니다. 따라서 레파지토리를 인터페이스로 정의하면 다른 인터페이스를 상속하여 필요한 기능을 확장할 수 있습니다.
    
2. **유연성**: 인터페이스를 사용하면 다른 구현체를 손쉽게 교체할 수 있습니다. 예를 들어, Spring Data JPA에서는 JpaRepository를 상속한 인터페이스를 정의하면 Spring이 해당 인터페이스에 대한 구현체를 자동으로 생성하여 빈으로 등록해줍니다. 따라서 개발자는 인터페이스만 정의하고 실제 구현은 Spring이 담당하므로 유연하게 데이터 액세스 레이어를 변경할 수 있습니다.
    
3. **테스트 용이성**: 인터페이스를 사용하면 테스트를 위해 가짜(Mock) 객체를 생성하여 쉽게 목(mock) 객체를 생성할 수 있습니다. 이를 통해 레파지토리와 관련된 테스트를 보다 쉽게 작성할 수 있습니다.
    
4. **코드의 추상화**: 인터페이스를 사용하면 구현체에 대한 세부 사항을 감춤으로써 코드의 추상화를 실현할 수 있습니다. 이는 인터페이스를 통해 프로그램의 의존성을 낮추고 코드의 유지 보수성을 향상시킬 수 있습니다.
```